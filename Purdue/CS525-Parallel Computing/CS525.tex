\documentclass{../../ainote}

%%%%Basic Info%%%%
\author{\ccLogo \,\,Xiyuan Chen}
\title{\textsc{CS525 Parallel Computing}}
\date{Spring Term, 2024}
%%%%%%%%%%%%%%%%%%

%%%%Document Beginner%%%%
\begin{document}
\maketitle
\doclicenseThis
\section*{Information}
\begin{itemize}
	\item No slides, no textbook.
\end{itemize}
\tableofcontents
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%

%% Main Body
\section{Application properties of parallelism}
\begin{itemize}
    \item Simulations. e.g., weather forecasting, molecular dynamics, etc.
    \item Learning \& Data Analysis. e.g., machine learning, data mining, etc.
\end{itemize}

\section{Parallel Programming Platforms}
There is no slides but I found a past course slide for reference. \href{https://www.cs.purdue.edu/homes/ayg/CS525_SPR17/chap2_slides.pdf}{here}.

\subsection{Processors}
Jobs of a processor: 1. fetch instructions. 2. decode instructions. 3. execute instructions. 4. store results.

Most of the time, the instructions are of few types: e.g. MOVE, ADD, LD, FSD

\subsubsection{Pipeline Parallelism}
Basic idea: an instruction can be executed while the next one is being decoded and the next one is being fetched.
\imgc{pipelining.jpg}{Pipeline Parallelism}{0.6}

Limitations: 
\begin{itemize}
    \item \blue{Bottleneck}: the slowest stage determines the speed of the pipeline. We solve by 1. \textbf{decpmosing} the slowest stage into multiple stages. 2. Use multiple pipelines (\textbf{Superscalar Excution}).
    \item \blue{Conditional jumps}: the pipeline must be flushed when a branch is encountered. We solve by \textbf{branch prediction}.
\end{itemize}

\paragraph{Superscalar Execution}\mbox{}

How to schedule instructions to multiple pipelines? We consider:
\begin{itemize}
    \item Data Dependencies: the result of one operation is an input to the next.
    \item Read Dependencies: the result of one operation is read by the next.
    \item Control Dependencies: the next operation depends on the result of a conditional branch.
    \item Resource Dependencies: the next operation requires the same resource as the current one.
\end{itemize}

We also \textbf{unroll the loops} to expose more parallelism.


\end{document}